{"version":3,"names":[],"mappings":"","sources":["services/cryptoService.js"],"sourcesContent":["/**\n * Handles all methods dealing with hashing and building a signature for the API calls.\n * This angular version of the SHA-1 hash is based on an implementation in JavaScript by Chris Veness 2002-2014 / MIT Licence\n *\n *\n * To use this service, inject it where you need it and add calls to this service whereever you are calling\n * $http.get or post.\n *\n * For Example:\n * var params = {\n                                    locale:locale,\n                                    userid:cryptoService.getSignatureUser(),\n                                    authentication_token:cryptoService.getSecretKey(),\n                                    timestamp: cryptoService.getSignatureTime(),\n                                    signature:cryptoService.getSignature()\n                                };\n                                return $http.get(urlString,{params:params}).success(function(response){\n                                    //do something\n                                }).error(function(response){\n                                   //throw some error.\n                                });\n\n  NOTE: Make sure to add you userid and key below. A key for your account can be generated in the Slatwall Admin by going to Account and\n                adding an API key.\n\n **/\n'use strict';\nangular.module('slatwalladmin').factory('cryptoService', ['$log', function ($log) {\n    //Make sure that String can encode and decode utf8 messages.    \n    if (typeof String.prototype.utf8Encode == 'undefined') {\n        String.prototype.utf8Encode = function () {\n            return unescape(encodeURIComponent(this));\n        };\n    }\n    /** Extend String object with method to decode utf8 string to multi-byte */\n    if (typeof String.prototype.utf8Decode == 'undefined') {\n        String.prototype.utf8Decode = function () {\n            try {\n                return decodeURIComponent(escape(this));\n            }\n            catch (e) {\n                return this; // invalid UTF-8? return as-is\n            }\n        };\n    }\n    var cryptoService = {\n        /**\n         * Returns a new signature based on a unix timestamp, accountID (uid), and secretKey all hashed together\n         * using sha1 algorithm.\n         */\n        getSignature: function () {\n            $log.debug(\"Creating a signature\");\n            //$log.debug(\"Key Plain: \" + \"A1E4E94C-D2A6-3462-235FFD1EF3339E0C\");//This confirms that this algoithm works.\n            //$log.debug(\"Key Sha1: \" + cryptoService.hash(\"A1E4E94C-D2A6-3462-235FFD1EF3339E0C\"));\n            var timeUserKey = cryptoService.getSignatureTime() + '_' + cryptoService.getSignatureUser() + '_' + cryptoService.getSecretKey();\n            //$log.debug(\"timeUserKey: \" + timeUserKey);\n            //hash using sha1\n            var sha1Text = cryptoService.hash(timeUserKey);\n            //$log.debug(\"Hashed: \" +sha1Text );\n            //encode to base64\n            var upperHash = sha1Text.toUpperCase();\n            var signature = btoa(upperHash);\n            //$log.debug(\"Binary Signature: \" + signature);\n            //return the signature.\n            return signature;\n        },\n        getSignatureTime: function () {\n            return (new Date).getTime();\n        },\n        getSignatureUser: function () {\n            //var uid = \"Your Userid Goes Here\";\n            return \"4028818d4b05b871014b102d388a00db\";\n        },\n        getSecretKey: function () {\n            //var key = \"Your Key Goes Here\";\n            return \"QTFFNEU5NEMtRDJBNi0zNDYyLTIzNUZGRDFFRjMzMzlFMEM=\";\n        },\n        hash: function (msg) {\n            msg = msg.utf8Encode();\n            var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n            msg += String.fromCharCode(0x80);\n            var l = msg.length / 4 + 2;\n            var N = Math.ceil(l / 16);\n            var M = new Array(N);\n            for (var i = 0; i < N; i++) {\n                M[i] = new Array(16);\n                for (var j = 0; j < 16; j++) {\n                    M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n                }\n            }\n            M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32);\n            M[N - 1][14] = Math.floor(M[N - 1][14]);\n            M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n            var H0 = 0x67452301;\n            var H1 = 0xefcdab89;\n            var H2 = 0x98badcfe;\n            var H3 = 0x10325476;\n            var H4 = 0xc3d2e1f0;\n            var W = new Array(80);\n            var a, b, c, d, e;\n            for (var i = 0; i < N; i++) {\n                for (var t = 0; t < 16; t++)\n                    W[t] = M[i][t];\n                for (var t = 16; t < 80; t++)\n                    W[t] = cryptoService.ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n                a = H0;\n                b = H1;\n                c = H2;\n                d = H3;\n                e = H4;\n                for (var t = 0; t < 80; t++) {\n                    var s = Math.floor(t / 20);\n                    var T = (cryptoService.ROTL(a, 5) + cryptoService.f(s, b, c, d) + e + K[s] + W[t]) & 0xffffffff;\n                    e = d;\n                    d = c;\n                    c = cryptoService.ROTL(b, 30);\n                    b = a;\n                    a = T;\n                }\n                H0 = (H0 + a) & 0xffffffff;\n                H1 = (H1 + b) & 0xffffffff;\n                H2 = (H2 + c) & 0xffffffff;\n                H3 = (H3 + d) & 0xffffffff;\n                H4 = (H4 + e) & 0xffffffff;\n            }\n            return cryptoService.toHexStr(H0) + cryptoService.toHexStr(H1) + cryptoService.toHexStr(H2) + cryptoService.toHexStr(H3) + cryptoService.toHexStr(H4);\n        },\n        f: function (s, x, y, z) {\n            switch (s) {\n                case 0: return (x & y) ^ (~x & z);\n                case 1: return x ^ y ^ z;\n                case 2: return (x & y) ^ (x & z) ^ (y & z);\n                case 3: return x ^ y ^ z;\n            }\n        },\n        ROTL: function (x, n) {\n            return (x << n) | (x >>> (32 - n));\n        },\n        toHexStr: function (n) {\n            var s = \"\", v;\n            for (var i = 7; i >= 0; i--) {\n                v = (n >>> (i * 4)) & 0xf;\n                s += v.toString(16);\n            }\n            return s;\n        }\n    };\n    return cryptoService;\n}]);\n\n//# sourceMappingURL=../services/cryptoService.js.map"],"file":"services/cryptoService.js","sourceRoot":"/source/"}